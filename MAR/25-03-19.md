# TIL 

## 날짜: 2025-03-19

### 스크럼
- 학습 목표 1 : JPA의 캐시(1차 캐시와 2차 캐시), 연관 관계 매핑, Fetch 전략 선택 기준, JPQL과 네이티브 쿼리

### 새로 배운 내용
---
#### 🚛 주제 1: JPA의 캐시
- 1차 캐시와 2차 캐시는? **성능 최적화를 위한 캐싱 매커니즘**이다. 영속성 컨텍스트와 관련 있다.
- 1차 캐시
  - 저장 위치: 영속성 컨텍스트 (EntityManager) 내부
  - 특징: 기본 제공이며, 개별 트랜잭션마다 유지된다.
  - 동작 방식: 엔티티 조회 시, 먼저 1차 캐시 확인 후 없으면 디비에서 조회해 캐시에 저장한다.
- 2차 캐시
  - 저장 위치: 애플리케이션 레벨 (전역)
  - 특징: 설정이 필요하며, 여러 트랜잭션 간 공유가 가능하다.
  - 동작 방식: 1차 캐시에 없는 데이터를 디비 대신 2차 캐시에서 가져올 수 있다. 

---
#### 🚛 주제 2: 연관 관계 매핑
- JPA에서 테이블 간 관계를 객체 지향적으로 매핑한다. 객체 간의 연관 관계를 매핑하는 방법은 4가지가 있다. 
- @OneToOne (회원 <-> 회원 상세 정보)
  - 양쪽 엔티티 중 하나가 주 테이블이 된다. 
  - 자주 접근하는 테이블을 주 텡블로 설정하고, 주 테이블이 외래 키를 가진다.  
- @OneToMany/@ManyToOne (팀 <-> 멤버)
  - 일대다 단방향은 지양하는게 좋다. (팀 엔티티가 연관관계의 주인이며 @JoinColumn을 팀 엔티티에 작성한다. 하지만 실제 외래키는 테이블에 생성되어, 쿼리가 복잡하고 성능 저하가 발생한다.)
  - 컬렉션 필드는 항상 필드 초기화를 권장한다. (NullPointerException 방지)
- @ManyToMany (게시글 <-> 회원)
  - 다대다는 지양하고, 중간 엔티티(매핑 테이블)을 따로 두어 @OneToMany + @ManyToOne 형식으로 푼다. 
- 중요
  - mappedBy: 연관 관계의 주인 설정 (연관 관계를 관리하는 엔티티)
  - Cascade: 연관된 엔티티의 변경을 자동으로 반영 (부모 삭제 시 자식도 삭제)
  - Featch 전략과 함께 사용됨. (Lazy를 사용할 경우, 지연 로딩된 데이터를 가져올 때 엔티티 그래프를 활용할 수도 있다.)
---
#### 🚛 주제 3: Fetch 전략
- 성능 최적화를 위해 Eager Loading과 Lazy Loading을 결정한다.
- Eager
  - 동작 방식: 연관된 엔티티를 즉시 로드한다.
  - 장점: 간단한 조회에 적합
  - 단점: 불필요한 데이터 로드 가능성 (N+1 문제)
  - 사용 예시: 자주 함꼐 조회되는 관계 (@ManyToOne)
- Lazy
  - 동작 방식: 필요할 때 연관된 엔티티를 로드한다.
  - 장점: 불필요한 로드를 방지함
  - 단점: 연관된 엔티티를 사용할 떄 추가 쿼리가 발생
  - 사용 예시: 대부분의 연관 관계
---
#### 🚛 주제 4: JPQL & 네이티브 쿼리 
- 데이터를 조회하는 방법이다.
- JPQL
  - SQL처럼 디비 테이블을 대상으로 쿼리를 날리는 것이 아니라, 엔티티 객체를 대상으로 날리는 쿼리.
  - DB 독립적, 복잡한 쿼리 작성 어려움.
- 네이티브 쿼리
  - 디비 전용 SQL을 직접 작성하는 방법.
  - 복잡한 쿼리 최적화 가능, DB 종속적, 유지보수 어려움. 
---
### 오늘의 회고
- JPA의 핵심 개념인 캐시, 연관 관계 매핑, Fetch 전략, JPQL과 네이티브 쿼리에 대해 공부했다. 모두 실제 프로젝트에서 성능 최적화와 유지보수를 고려해 설계해야 하는 중요한 개념들이다.
- JPA 캐시 공부 이전에, 디비에서 바로 가져오면 된다고 생각했었는데, 캐시를 활용해 불필요한 디비 조회를 줄여서 성능을 개선할 수 있다는 것이 인상적이었다. 1차 캐시는 영속성 컨텍스트 기능에서 봤었는데, 2차 캐시를 설정할 수 있다는 것도 알게 되었다. 이제 JPA를 사용할 때, 엔티티 조회 시 먼저 캐시를 확인하고, 없을 때만 디비에서 가져온다는 흐름을 알게 되었다.
- JPA에서는 객체 간 관계를 매핑할 수 있지만, 필요에 따라 단방향과 양방향을 적절히 설계해야 한다는 점이 중요했다. 특히 OneToMany 단방향은 피하고, ManyToMany도 중간 엔티티를 만들어 풀어야 한다는 것을 알게 되었다. 또한 Cascade의 중요성에 대해서도 알게 되었다. Cascade를 사용하면 부모 엔티티가 변경될 때 자식 엔티티까지 자동으로 반영되지만, 잘못 사용하면 의도치 않은 데이터 삭제가 발생할 수도 있어 주의해야 한다.
- 연관된 데이터를 가져올 때 Eager/Lazy 로딩을 적절히 사용해야 한다는 것을 알게 되었다.
- 앞으로 실제 프로젝트에서 Fetch 전략을 어떻게 선택할지 더 고민해봐야겠다. 또 JPQL과 네이티브 쿼리는 직접 작성해보면서 익히고 싶다. N+1 문제가 영속성 컨텍스트를 공부할 때부터 계속 나오고 있는데, 아직 완벽히 이해되지는 않지만 반복적으로 언급되고 있어 중요한 내용인 것 같다. 다음 시간에 N+1 문제를 제대로 이해해봐야겠다.
- JPA를 단순히 사용하는 것을 넘어서, "어떻게 하면 더 효율적인 방식으로 데이터를 조회하고 관리할 수 있을까"를 고민해야겠다고 느꼈다.

### 참고 자료 및 링크
- 
